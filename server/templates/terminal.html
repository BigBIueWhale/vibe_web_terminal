<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Terminal - {{ session_id[:8] }}</title>
    <!-- xterm.js (vendored from @xterm/xterm@5.5.0) -->
    <link rel="stylesheet" href="/static/xterm/xterm.min.css">
    <script src="/static/xterm/xterm.min.js"></script>
    <script src="/static/xterm/addon-fit.min.js"></script>
    <script src="/static/xterm/addon-web-links.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            background: #2d2d2d;
            padding: 0.5rem 1rem;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #444;
            flex-shrink: 0;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .logo {
            font-weight: bold;
            font-size: 1.1rem;
            color: #00d4ff;
            text-decoration: none;
        }

        .logo:hover {
            color: #33ddff;
        }

        .session-info {
            font-size: 0.85rem;
            color: #888;
        }

        .session-id {
            font-family: monospace;
            background: #3d3d3d;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
        }

        .session-id:hover {
            background: #4d4d4d;
        }

        .header-right {
            display: flex;
            gap: 0.5rem;
        }

        .btn {
            background: #3d3d3d;
            border: none;
            color: #e0e0e0;
            padding: 0.4rem 0.8rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.85rem;
            transition: background 0.2s;
        }

        .btn:hover {
            background: #4d4d4d;
        }

        .btn-upload {
            background: #7c3aed;
        }

        .btn-upload:hover {
            background: #8b5cf6;
        }

        .terminal-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #terminal-display {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
        }

        /* xterm.js overrides - match ttyd's approach */
        .terminal {
            padding: 0;
            height: 100%;
        }

        .xterm-viewport::-webkit-scrollbar {
            width: 10px;
        }

        .xterm-viewport::-webkit-scrollbar-track {
            background: #1a1a1a;
        }

        .xterm-viewport::-webkit-scrollbar-thumb {
            background: #444;
            border-radius: 5px;
        }

        .xterm-viewport::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        /* Terminal overlay for status messages */
        .terminal-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(240, 240, 240, 0.95);
            color: #101010;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            z-index: 100;
            display: none;
            text-align: center;
            max-width: 80%;
        }

        .terminal-overlay.show {
            display: block;
        }

        .terminal-overlay.error {
            background: rgba(248, 113, 113, 0.95);
            color: white;
        }

        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            gap: 1rem;
        }

        .loading-overlay.hidden {
            display: none;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid #3d3d3d;
            border-top-color: #00d4ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Upload modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #2d2d2d;
            padding: 2rem;
            border-radius: 12px;
            min-width: 500px;
            max-width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .modal-header h2 {
            font-size: 1.2rem;
        }

        .modal-close {
            background: none;
            border: none;
            color: #888;
            font-size: 1.5rem;
            cursor: pointer;
        }

        .upload-options {
            display: flex;
            gap: 1rem;
            margin-bottom: 1rem;
        }

        .upload-zone {
            flex: 1;
            border: 2px dashed #444;
            border-radius: 8px;
            padding: 1.5rem;
            text-align: center;
            transition: border-color 0.2s, background 0.2s;
            cursor: pointer;
        }

        .upload-zone:hover,
        .upload-zone.dragover {
            border-color: #7c3aed;
            background: rgba(124, 58, 237, 0.1);
        }

        .upload-zone input {
            display: none;
        }

        .upload-zone label {
            cursor: pointer;
            display: block;
        }

        .upload-zone .icon {
            font-size: 2rem;
            margin-bottom: 0.5rem;
        }

        .upload-zone .text {
            font-size: 0.9rem;
        }

        .upload-progress {
            margin-top: 1rem;
            max-height: 300px;
            overflow-y: auto;
        }

        .progress-item {
            background: #3d3d3d;
            border-radius: 4px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-size: 0.85rem;
        }

        .progress-filename {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            max-width: 300px;
        }

        .progress-bar-container {
            background: #2d2d2d;
            border-radius: 4px;
            height: 6px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #7c3aed, #00d4ff);
            transition: width 0.2s;
            border-radius: 4px;
        }

        .progress-bar.complete {
            background: #4ade80;
        }

        .progress-bar.error {
            background: #f87171;
        }

        .file-list {
            max-height: 400px;
            overflow-y: auto;
        }

        .file-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.75rem;
            background: #3d3d3d;
            border-radius: 4px;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            transition: background 0.15s;
        }

        .file-item:hover {
            background: #4d4d4d;
        }

        .file-item-name {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            overflow: hidden;
            flex: 1;
            cursor: pointer;
        }

        .file-item-name span {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .file-item-name.clickable:hover {
            color: #00d4ff;
        }

        .file-meta {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            flex-shrink: 0;
        }

        .file-size {
            color: #888;
            font-size: 0.8rem;
            min-width: 70px;
            text-align: right;
        }

        .file-actions {
            display: flex;
            gap: 0.25rem;
        }

        .btn-icon {
            background: #4d4d4d;
            border: none;
            color: #e0e0e0;
            padding: 0.3rem 0.5rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: background 0.15s;
        }

        .btn-icon:hover {
            background: #5d5d5d;
        }

        .btn-icon.download {
            background: #2563eb;
        }

        .btn-icon.download:hover {
            background: #3b82f6;
        }

        .breadcrumb {
            display: flex;
            align-items: center;
            gap: 0.25rem;
            margin-bottom: 1rem;
            padding: 0.5rem 0.75rem;
            background: #3d3d3d;
            border-radius: 4px;
            font-size: 0.85rem;
            overflow-x: auto;
            white-space: nowrap;
        }

        .breadcrumb-item {
            color: #00d4ff;
            cursor: pointer;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
        }

        .breadcrumb-item:hover {
            background: #4d4d4d;
        }

        .breadcrumb-sep {
            color: #666;
        }

        .breadcrumb-current {
            color: #e0e0e0;
        }

        .browser-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .browser-actions {
            display: flex;
            gap: 0.5rem;
        }

        .btn-sm {
            padding: 0.35rem 0.7rem;
            font-size: 0.8rem;
        }

        .btn-sm.download {
            background: #2563eb;
        }

        .btn-sm.download:hover {
            background: #3b82f6;
        }

        .empty-state {
            color: #888;
            text-align: center;
            padding: 2rem;
        }

        .toast {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #4ade80;
            color: #1a1a1a;
            padding: 0.75rem 1.5rem;
            border-radius: 8px;
            font-weight: 500;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s;
            z-index: 2000;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast.error {
            background: #f87171;
        }

        .help-text {
            font-size: 0.8rem;
            color: #888;
            margin-top: 0.5rem;
        }

        .upload-stats {
            display: flex;
            gap: 2rem;
            margin-top: 1rem;
            padding: 0.75rem;
            background: #3d3d3d;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .stat {
            display: flex;
            flex-direction: column;
        }

        .stat-label {
            color: #888;
            font-size: 0.75rem;
        }

        .stat-value {
            font-weight: 600;
            color: #00d4ff;
        }

        /* Sessions dropdown */
        .sessions-dropdown-wrap {
            position: relative;
        }

        .sessions-dropdown {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            margin-top: 0.35rem;
            background: #2d2d2d;
            border: 1px solid #444;
            border-radius: 8px;
            min-width: 300px;
            z-index: 500;
            box-shadow: 0 8px 24px rgba(0,0,0,0.5);
            overflow: hidden;
        }

        .sessions-dropdown.open {
            display: block;
        }

        .sessions-dropdown-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0.75rem;
            border-bottom: 1px solid #444;
            font-size: 0.8rem;
            color: #888;
        }

        .sessions-dropdown-list {
            max-height: 280px;
            overflow-y: auto;
        }

        .sd-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 0.75rem;
            font-size: 0.85rem;
            transition: background 0.1s;
            text-decoration: none;
            color: #e0e0e0;
        }

        .sd-item:hover {
            background: #3d3d3d;
        }

        .sd-item.current {
            background: rgba(0, 212, 255, 0.1);
            border-left: 2px solid #00d4ff;
        }

        .sd-dot {
            width: 7px;
            height: 7px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .sd-dot.running { background: #4ade80; }
        .sd-dot.stopped { background: #f87171; }
        .sd-dot.unknown { background: #888; }

        .sd-label {
            font-family: monospace;
            flex: 1;
        }

        .sd-status {
            color: #888;
            font-size: 0.75rem;
        }

        .sd-delete {
            background: transparent;
            border: none;
            color: #f87171;
            cursor: pointer;
            font-size: 0.75rem;
            padding: 0.15rem 0.4rem;
            border-radius: 3px;
            opacity: 0.6;
            transition: opacity 0.15s, background 0.15s;
            flex-shrink: 0;
        }

        .sd-delete:hover {
            opacity: 1;
            background: rgba(248, 113, 113, 0.15);
        }

        .btn-new-sm {
            background: linear-gradient(90deg, #7c3aed, #00d4ff);
            border: none;
            color: white;
            padding: 0.25rem 0.6rem;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.75rem;
        }

        .btn-new-sm:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .sd-limit {
            font-size: 0.7rem;
            color: #666;
            padding: 0.3rem 0.75rem;
            border-top: 1px solid #333;
            text-align: center;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-left">
            <div class="sessions-dropdown-wrap">
                <button class="btn" id="sessionsBtn" onclick="toggleSessionsDropdown()">Sessions</button>
                <div class="sessions-dropdown" id="sessionsDropdown">
                    <div class="sessions-dropdown-header">
                        <span>Your Sessions</span>
                        <button class="btn-new-sm" id="newSessionBtn" onclick="newSession()">+ New</button>
                    </div>
                    <div class="sessions-dropdown-list" id="sessionsDropdownList">
                        <div class="sd-item" style="color:#888; cursor:default;">Loading...</div>
                    </div>
                    <div class="sd-limit" id="sessionsLimit"></div>
                </div>
            </div>
            <a href="javascript:void(0)" onclick="navigateAway('/')" class="logo">Vibe Terminal</a>
            <div class="session-info">
                Session: <span class="session-id" onclick="copySessionId()" title="Click to copy full URL">{{ session_id[:8] }}...</span>
            </div>
        </div>
        <div class="header-right">
            <button class="btn" onclick="showFiles()">Files</button>
            <button class="btn btn-upload" onclick="showUpload()">Upload</button>
        </div>
    </div>

    <div class="terminal-container">
        <div class="loading-overlay" id="loadingOverlay">
            <div class="spinner"></div>
            <p>Connecting to terminal...</p>
        </div>
        <div id="terminal-display"></div>
        <div class="terminal-overlay" id="terminalOverlay"></div>
    </div>

    <!-- Upload Modal -->
    <div class="modal" id="uploadModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Upload Files & Folders</h2>
                <button class="modal-close" onclick="hideUpload()">&times;</button>
            </div>

            <div class="upload-options">
                <div class="upload-zone" id="uploadZoneFiles">
                    <input type="file" id="fileInput" multiple onchange="handleFileSelect(this.files)">
                    <label for="fileInput">
                        <div class="icon">üìÑ</div>
                        <div class="text">Drop files or click</div>
                    </label>
                </div>
                <div class="upload-zone" id="uploadZoneFolder">
                    <input type="file" id="folderInput" webkitdirectory directory multiple onchange="handleFolderSelect(this.files)">
                    <label for="folderInput">
                        <div class="icon">üìÅ</div>
                        <div class="text">Upload folder</div>
                    </label>
                </div>
            </div>

            <p class="help-text">Files upload to /home/vibe/workspace/ ‚Ä¢ Folders preserve structure ‚Ä¢ Max 500MB per file</p>

            <div class="upload-stats" id="uploadStats" style="display: none;">
                <div class="stat">
                    <span class="stat-label">Files</span>
                    <span class="stat-value" id="statFiles">0 / 0</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Size</span>
                    <span class="stat-value" id="statSize">0 B</span>
                </div>
                <div class="stat">
                    <span class="stat-label">Speed</span>
                    <span class="stat-value" id="statSpeed">-- MB/s</span>
                </div>
            </div>

            <div class="upload-progress" id="uploadProgress"></div>
        </div>
    </div>

    <!-- Files Modal -->
    <div class="modal" id="filesModal">
        <div class="modal-content" style="min-width: 600px;">
            <div class="modal-header">
                <h2>File Browser</h2>
                <button class="modal-close" onclick="hideFiles()">&times;</button>
            </div>

            <div class="browser-header">
                <div class="breadcrumb" id="breadcrumb">
                    <span class="breadcrumb-item" onclick="browseTo('')">workspace</span>
                </div>
                <div class="browser-actions">
                    <button class="btn btn-sm" onclick="refreshBrowser()">Refresh</button>
                    <button class="btn btn-sm download" id="downloadAllBtn" onclick="downloadCurrentDir()">Download All (7z)</button>
                </div>
            </div>

            <div class="file-list" id="workspaceFiles">
                <div class="empty-state">Loading...</div>
            </div>
            <p class="help-text">Container path: /home/vibe/workspace/<span id="currentPathDisplay"></span></p>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        const sessionId = "{{ session_id }}";
        let uploadQueue = [];
        let uploadStats = { completed: 0, total: 0, bytes: 0, startTime: 0 };
        let cachedMaxSessions = 3;

        // =================================================================
        // Terminal Configuration and State
        // =================================================================
        const termConfig = {
            fontSize: 14,
            fontFamily: "Consolas, 'Liberation Mono', Menlo, Courier, monospace",
            fontWeight: '400',
            fontWeightBold: '600',
            cursorStyle: 'bar',
            cursorBlink: true,
            scrollback: 10000,
            allowProposedApi: true,
            theme: {
                foreground: '#d2d2d2',
                background: '#1a1a1a',
                cursor: '#adadad',
                cursorAccent: '#1a1a1a',
                selectionBackground: 'rgba(255, 255, 255, 0.3)',
                black: '#000000',
                red: '#d81e00',
                green: '#5ea702',
                yellow: '#cfae00',
                blue: '#427ab3',
                magenta: '#89658e',
                cyan: '#00a7aa',
                white: '#dbded8',
                brightBlack: '#686a66',
                brightRed: '#f54235',
                brightGreen: '#99e343',
                brightYellow: '#fdeb61',
                brightBlue: '#84b0d8',
                brightMagenta: '#bc94b7',
                brightCyan: '#37e6e8',
                brightWhite: '#f1f1f0',
            }
        };

        let term = null;
        let fitAddon = null;
        let cursor = 0;
        let connected = false;
        let pollController = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;

        // =================================================================
        // Terminal Initialization
        // =================================================================
        function initTerminal() {
            const container = document.getElementById('terminal-display');

            term = new Terminal(termConfig);
            fitAddon = new FitAddon.FitAddon();
            const webLinksAddon = new WebLinksAddon.WebLinksAddon();

            term.loadAddon(fitAddon);
            term.loadAddon(webLinksAddon);

            term.open(container);

            // Handle user input
            term.onData(data => {
                sendInput(data);
            });

            // Handle binary input (paste with special chars)
            term.onBinary(data => {
                const bytes = new Uint8Array(data.length);
                for (let i = 0; i < data.length; i++) {
                    bytes[i] = data.charCodeAt(i);
                }
                sendInput(bytes);
            });

            // Handle resize
            let resizeTimeout = null;
            const handleResize = () => {
                fitAddon.fit();
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (connected) {
                        sendResize(term.cols, term.rows);
                    }
                }, 100);
            };

            window.addEventListener('resize', handleResize);
            new ResizeObserver(handleResize).observe(container);

            // Fit terminal and connect after layout is stable
            // The container may not have final dimensions immediately
            const doInitialFit = () => {
                fitAddon.fit();
                // Connect with proper dimensions
                connect();
            };

            // Wait for next frame to ensure CSS layout is complete
            requestAnimationFrame(() => {
                fitAddon.fit();
                // Another frame to be safe, then connect
                requestAnimationFrame(doInitialFit);
            });
        }

        // =================================================================
        // HTTP Terminal Connection
        // =================================================================
        async function connect() {
            showOverlay('Connecting...', false);

            try {
                const resp = await fetch(`/terminal/${sessionId}/connect`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
                    body: `cols=${term.cols}&rows=${term.rows}`
                });

                if (!resp.ok) {
                    const data = await resp.json().catch(() => ({ detail: 'Connection failed' }));
                    throw new Error(data.detail || `HTTP ${resp.status}`);
                }

                connected = true;
                reconnectAttempts = 0;
                hideLoading();
                hideOverlay();
                term.focus();
                poll();

            } catch (e) {
                console.error('Connection error:', e);
                showOverlay(`Connection failed: ${e.message}`, true);

                // Auto-retry with backoff
                reconnectAttempts++;
                if (reconnectAttempts < maxReconnectAttempts) {
                    const delay = Math.min(1000 * Math.pow(2, reconnectAttempts), 10000);
                    setTimeout(connect, delay);
                } else {
                    showOverlay('Connection failed. Click to retry.', true);
                }
            }
        }

        // =================================================================
        // Long-Polling for Output
        // =================================================================
        async function poll() {
            if (!connected) return;

            pollController = new AbortController();

            try {
                const resp = await fetch(
                    `/terminal/${sessionId}/poll?cursor=${cursor}&timeout=30`,
                    { signal: pollController.signal }
                );

                if (!resp.ok) {
                    if (resp.status === 410) {
                        // Terminal disconnected
                        connected = false;
                        showOverlay('Terminal disconnected. Click to reconnect.', true);
                        return;
                    }
                    if (resp.status === 401) {
                        // Session expired
                        window.location.href = '/login?next=' + encodeURIComponent(window.location.pathname);
                        return;
                    }
                    throw new Error(`Poll failed: HTTP ${resp.status}`);
                }

                const result = await resp.json();

                if (result.data) {
                    // Decode base64 and write to terminal
                    const bytes = Uint8Array.from(atob(result.data), c => c.charCodeAt(0));
                    term.write(bytes);
                }

                if (result.missed) {
                    console.warn('Missed some terminal output (buffer overflow)');
                }

                cursor = result.cursor;

                // Continue polling
                poll();

            } catch (e) {
                if (e.name === 'AbortError') {
                    return; // Intentional abort
                }

                console.error('Poll error:', e);

                // Retry after delay if still connected
                if (connected) {
                    setTimeout(poll, 1000);
                }
            }
        }

        // =================================================================
        // Send Input to Terminal
        // =================================================================
        async function sendInput(data) {
            if (!connected) return;

            try {
                const body = typeof data === 'string'
                    ? new TextEncoder().encode(data)
                    : data;

                await fetch(`/terminal/${sessionId}/input`, {
                    method: 'POST',
                    body: body
                });
            } catch (e) {
                console.error('Input error:', e);
            }
        }

        // =================================================================
        // Send Resize to Terminal
        // =================================================================
        async function sendResize(cols, rows) {
            if (!connected) return;

            try {
                await fetch(`/terminal/${sessionId}/resize?cols=${cols}&rows=${rows}`, {
                    method: 'POST'
                });
            } catch (e) {
                console.error('Resize error:', e);
            }
        }

        // =================================================================
        // Overlay Helpers
        // =================================================================
        function showOverlay(message, isError = false) {
            const overlay = document.getElementById('terminalOverlay');
            overlay.textContent = message;
            overlay.className = 'terminal-overlay show' + (isError ? ' error' : '');
        }

        function hideOverlay() {
            const overlay = document.getElementById('terminalOverlay');
            overlay.className = 'terminal-overlay';
        }

        // Click on overlay to reconnect
        document.getElementById('terminalOverlay').addEventListener('click', () => {
            if (!connected) {
                reconnectAttempts = 0;
                cursor = 0;
                connect();
            }
        });

        function hideLoading() {
            document.getElementById('loadingOverlay').classList.add('hidden');
        }

        function copySessionId() {
            navigator.clipboard.writeText(window.location.href);
            showToast('Session URL copied to clipboard!');
        }

        function showToast(message, isError = false) {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = 'toast show' + (isError ? ' error' : '');
            setTimeout(() => toast.classList.remove('show'), 3000);
        }

        function showUpload() {
            document.getElementById('uploadModal').classList.add('show');
        }

        function hideUpload() {
            document.getElementById('uploadModal').classList.remove('show');
        }

        let currentBrowsePath = '';

        function showFiles() {
            document.getElementById('filesModal').classList.add('show');
            browseTo('');
        }

        function hideFiles() {
            document.getElementById('filesModal').classList.remove('show');
        }

        async function browseTo(path) {
            currentBrowsePath = path;
            const container = document.getElementById('workspaceFiles');
            container.innerHTML = '<div class="empty-state">Loading...</div>';

            try {
                const response = await fetch(`/session/${sessionId}/browse?path=${encodeURIComponent(path)}`);
                if (!response.ok) throw new Error('Failed to load');
                const data = await response.json();

                updateBreadcrumb(data.path);
                document.getElementById('currentPathDisplay').textContent = data.path;

                if (data.files.length === 0) {
                    container.innerHTML = '<div class="empty-state">This folder is empty</div>';
                } else {
                    container.innerHTML = data.files.map(f => {
                        const filePath = data.path ? `${data.path}/${f.name}` : f.name;
                        const escapedPath = filePath.replace(/'/g, "\\'");
                        const escapedName = f.name.replace(/</g, '&lt;').replace(/>/g, '&gt;');

                        if (f.is_dir) {
                            return `
                                <div class="file-item">
                                    <div class="file-item-name clickable" onclick="browseTo('${escapedPath}')">
                                        <span>üìÅ</span>
                                        <span>${escapedName}</span>
                                    </div>
                                    <div class="file-meta">
                                        <span class="file-size">${formatSize(f.size)}</span>
                                        <div class="file-actions">
                                            <button class="btn-icon download" onclick="download7z('${escapedPath}')" title="Download as 7z">7z</button>
                                        </div>
                                    </div>
                                </div>
                            `;
                        } else {
                            return `
                                <div class="file-item">
                                    <div class="file-item-name">
                                        <span>${getFileIcon(f.name)}</span>
                                        <span>${escapedName}</span>
                                    </div>
                                    <div class="file-meta">
                                        <span class="file-size">${formatSize(f.size)}</span>
                                        <div class="file-actions">
                                            <button class="btn-icon download" onclick="downloadFile('${escapedPath}')" title="Download">DL</button>
                                        </div>
                                    </div>
                                </div>
                            `;
                        }
                    }).join('');
                }
            } catch (e) {
                container.innerHTML = '<div class="empty-state" style="color: #f87171;">Failed to load files</div>';
            }
        }

        function updateBreadcrumb(path) {
            const breadcrumb = document.getElementById('breadcrumb');
            let html = '<span class="breadcrumb-item" onclick="browseTo(\'\')">workspace</span>';

            if (path) {
                const parts = path.split('/');
                let accumulated = '';
                for (let i = 0; i < parts.length; i++) {
                    accumulated = accumulated ? `${accumulated}/${parts[i]}` : parts[i];
                    const escapedPath = accumulated.replace(/'/g, "\\'");
                    const escapedName = parts[i].replace(/</g, '&lt;').replace(/>/g, '&gt;');

                    if (i === parts.length - 1) {
                        html += `<span class="breadcrumb-sep">/</span><span class="breadcrumb-current">${escapedName}</span>`;
                    } else {
                        html += `<span class="breadcrumb-sep">/</span><span class="breadcrumb-item" onclick="browseTo('${escapedPath}')">${escapedName}</span>`;
                    }
                }
            }

            breadcrumb.innerHTML = html;
        }

        function getFileIcon(filename) {
            const ext = filename.split('.').pop().toLowerCase();
            const icons = {
                'js': 'üìú', 'ts': 'üìú', 'jsx': 'üìú', 'tsx': 'üìú',
                'py': 'üêç', 'rb': 'üíé', 'go': 'üîµ', 'rs': 'ü¶Ä',
                'html': 'üåê', 'css': 'üé®', 'scss': 'üé®', 'less': 'üé®',
                'json': 'üìã', 'yaml': 'üìã', 'yml': 'üìã', 'xml': 'üìã',
                'md': 'üìù', 'txt': 'üìù', 'log': 'üìù',
                'png': 'üñºÔ∏è', 'jpg': 'üñºÔ∏è', 'jpeg': 'üñºÔ∏è', 'gif': 'üñºÔ∏è', 'svg': 'üñºÔ∏è', 'webp': 'üñºÔ∏è',
                'mp3': 'üéµ', 'wav': 'üéµ', 'ogg': 'üéµ',
                'mp4': 'üé¨', 'webm': 'üé¨', 'mov': 'üé¨',
                'zip': 'üì¶', 'tar': 'üì¶', 'gz': 'üì¶', 'rar': 'üì¶', '7z': 'üì¶',
                'pdf': 'üìï', 'doc': 'üìò', 'docx': 'üìò', 'xls': 'üìó', 'xlsx': 'üìó',
                'sh': '‚öôÔ∏è', 'bash': '‚öôÔ∏è', 'zsh': '‚öôÔ∏è',
            };
            return icons[ext] || 'üìÑ';
        }

        function refreshBrowser() {
            browseTo(currentBrowsePath);
        }

        function downloadFile(path) {
            const url = `/session/${sessionId}/download?path=${encodeURIComponent(path)}`;
            const a = document.createElement('a');
            a.href = url;
            a.download = path.split('/').pop();
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            showToast('Download started');
        }

        function download7z(path) {
            const url = `/session/${sessionId}/download-archive?path=${encodeURIComponent(path)}`;
            const a = document.createElement('a');
            a.href = url;
            a.download = (path.split('/').pop() || 'workspace') + '.7z';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            showToast('7z download started');
        }

        function downloadCurrentDir() {
            download7z(currentBrowsePath);
        }

        async function loadFiles() {
            await browseTo('');
        }

        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            if (bytes < 1024 * 1024 * 1024) return (bytes / 1024 / 1024).toFixed(1) + ' MB';
            return (bytes / 1024 / 1024 / 1024).toFixed(2) + ' GB';
        }

        function handleFileSelect(files) {
            uploadFilesWithProgress(Array.from(files), '');
        }

        function handleFolderSelect(files) {
            const fileList = Array.from(files);
            uploadFilesWithProgress(fileList, '');
        }

        async function uploadFilesWithProgress(files, basePath) {
            const progressContainer = document.getElementById('uploadProgress');
            const statsContainer = document.getElementById('uploadStats');

            uploadStats = {
                completed: 0,
                total: files.length,
                bytes: 0,
                totalBytes: files.reduce((sum, f) => sum + f.size, 0),
                startTime: Date.now()
            };

            statsContainer.style.display = 'flex';
            updateStats();

            for (const file of files) {
                const relativePath = file.webkitRelativePath || file.name;
                const displayName = relativePath.length > 40
                    ? '...' + relativePath.slice(-37)
                    : relativePath;

                const progressId = 'progress-' + Math.random().toString(36).substr(2, 9);
                progressContainer.insertAdjacentHTML('afterbegin', `
                    <div class="progress-item" id="${progressId}">
                        <div class="progress-header">
                            <span class="progress-filename" title="${relativePath}">${displayName}</span>
                            <span class="progress-status">0%</span>
                        </div>
                        <div class="progress-bar-container">
                            <div class="progress-bar" style="width: 0%"></div>
                        </div>
                    </div>
                `);

                try {
                    await uploadFileWithProgress(file, relativePath, progressId);
                    uploadStats.completed++;
                    uploadStats.bytes += file.size;
                    updateStats();
                } catch (e) {
                    const elem = document.getElementById(progressId);
                    if (elem) {
                        elem.querySelector('.progress-bar').className = 'progress-bar error';
                        elem.querySelector('.progress-status').textContent = 'Failed';
                    }
                    showToast(`Failed: ${file.name}`, true);
                }
            }

            if (uploadStats.completed === uploadStats.total) {
                showToast(`Uploaded ${uploadStats.completed} file(s)`);
            }
        }

        async function uploadFileWithProgress(file, relativePath, progressId) {
            return new Promise((resolve, reject) => {
                const xhr = new XMLHttpRequest();
                const formData = new FormData();
                formData.append('file', file);
                formData.append('path', relativePath);

                xhr.upload.onprogress = (e) => {
                    if (e.lengthComputable) {
                        const percent = Math.round((e.loaded / e.total) * 100);
                        const elem = document.getElementById(progressId);
                        if (elem) {
                            elem.querySelector('.progress-bar').style.width = percent + '%';
                            elem.querySelector('.progress-status').textContent = percent + '%';
                        }
                    }
                };

                xhr.onload = () => {
                    const elem = document.getElementById(progressId);
                    if (xhr.status >= 200 && xhr.status < 300) {
                        if (elem) {
                            elem.querySelector('.progress-bar').className = 'progress-bar complete';
                            elem.querySelector('.progress-bar').style.width = '100%';
                            elem.querySelector('.progress-status').textContent = '‚úì';
                        }
                        resolve();
                    } else {
                        reject(new Error(xhr.statusText));
                    }
                };

                xhr.onerror = () => reject(new Error('Network error'));

                xhr.open('POST', `/session/${sessionId}/upload`);
                xhr.send(formData);
            });
        }

        function updateStats() {
            document.getElementById('statFiles').textContent =
                `${uploadStats.completed} / ${uploadStats.total}`;
            document.getElementById('statSize').textContent =
                formatSize(uploadStats.bytes) + ' / ' + formatSize(uploadStats.totalBytes);

            const elapsed = (Date.now() - uploadStats.startTime) / 1000;
            if (elapsed > 0.5 && uploadStats.bytes > 0) {
                const speed = uploadStats.bytes / elapsed;
                document.getElementById('statSpeed').textContent =
                    formatSize(speed) + '/s';
            }
        }

        async function newSession() {
            const btn = document.getElementById('newSessionBtn');
            btn.disabled = true;
            try {
                const response = await fetch('/session/new', { method: 'POST' });
                const data = await response.json();
                if (response.ok) {
                    navigateAway(data.redirect);
                } else {
                    showToast(data.detail || 'Failed to create session', true);
                    btn.disabled = false;
                }
            } catch (e) {
                showToast('Failed to create session', true);
                btn.disabled = false;
            }
        }

        async function deleteSessionFromDropdown(sid, btn, event) {
            event.preventDefault();
            event.stopPropagation();
            btn.disabled = true;
            btn.textContent = '...';
            try {
                await fetch(`/session/${sid}`, { method: 'DELETE' });
                // If we deleted the current session, go home
                if (sid === sessionId) {
                    navigateAway('/');
                    return;
                }
                // Remove the item from dropdown
                const item = btn.closest('.sd-item');
                if (item) item.remove();
                // Refresh the dropdown to update counts
                await loadSessionsDropdown();
            } catch (e) {
                showToast('Failed to delete session', true);
                btn.disabled = false;
                btn.textContent = 'X';
            }
        }

        function sdStatusClass(status) {
            if (status === 'running') return 'running';
            if (status === 'exited' || status === 'dead' || status === 'gone') return 'stopped';
            return 'unknown';
        }

        async function loadSessionsDropdown() {
            const list = document.getElementById('sessionsDropdownList');
            const limitEl = document.getElementById('sessionsLimit');
            const newBtn = document.getElementById('newSessionBtn');

            try {
                const response = await fetch('/my/sessions');
                if (!response.ok) throw new Error('Failed');
                const data = await response.json();
                const sessions = data.sessions || [];
                cachedMaxSessions = data.max_sessions || 3;

                // Update limit display and new button state
                limitEl.textContent = `${sessions.length} / ${cachedMaxSessions} sessions`;
                newBtn.disabled = sessions.length >= cachedMaxSessions;

                if (sessions.length === 0) {
                    list.innerHTML = '<div class="sd-item" style="color:#888; cursor:default;">No sessions</div>';
                    return;
                }
                list.innerHTML = sessions.map(s => {
                    const isCurrent = s.id === sessionId;
                    const dotClass = sdStatusClass(s.status);
                    const statusText = s.status === 'running' ? 'Running' : (s.status || '?');
                    return `<a class="sd-item${isCurrent ? ' current' : ''}" href="javascript:void(0)" onclick="navigateAway('/terminal/${s.id}')">
                        <span class="sd-dot ${dotClass}"></span>
                        <span class="sd-label">${s.label}</span>
                        <span class="sd-status">${statusText}</span>
                        <button class="sd-delete" onclick="deleteSessionFromDropdown('${s.id}', this, event)" title="Delete session">X</button>
                    </a>`;
                }).join('');
            } catch (e) {
                list.innerHTML = '<div class="sd-item" style="color:#f87171; cursor:default;">Failed to load</div>';
            }
        }

        async function toggleSessionsDropdown() {
            const dd = document.getElementById('sessionsDropdown');
            if (dd.classList.contains('open')) {
                dd.classList.remove('open');
                return;
            }
            dd.classList.add('open');
            const list = document.getElementById('sessionsDropdownList');
            list.innerHTML = '<div class="sd-item" style="color:#888; cursor:default;">Loading...</div>';
            await loadSessionsDropdown();
        }

        // Close sessions dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const wrap = document.querySelector('.sessions-dropdown-wrap');
            if (wrap && !wrap.contains(e.target)) {
                document.getElementById('sessionsDropdown').classList.remove('open');
            }
        });

        // Drag and drop for files
        ['uploadZoneFiles', 'uploadZoneFolder'].forEach(id => {
            const zone = document.getElementById(id);

            zone.addEventListener('dragover', (e) => {
                e.preventDefault();
                zone.classList.add('dragover');
            });

            zone.addEventListener('dragleave', () => {
                zone.classList.remove('dragover');
            });

            zone.addEventListener('drop', (e) => {
                e.preventDefault();
                zone.classList.remove('dragover');

                const items = e.dataTransfer.items;
                if (items) {
                    const files = [];
                    const promises = [];

                    for (let i = 0; i < items.length; i++) {
                        const item = items[i].webkitGetAsEntry();
                        if (item) {
                            promises.push(traverseFileTree(item, '', files));
                        }
                    }

                    Promise.all(promises).then(() => {
                        if (files.length > 0) {
                            uploadFilesWithProgress(files, '');
                        }
                    });
                } else {
                    handleFileSelect(e.dataTransfer.files);
                }
            });
        });

        function traverseFileTree(item, path, files) {
            return new Promise((resolve) => {
                if (item.isFile) {
                    item.file((file) => {
                        Object.defineProperty(file, 'webkitRelativePath', {
                            value: path + file.name
                        });
                        files.push(file);
                        resolve();
                    });
                } else if (item.isDirectory) {
                    const dirReader = item.createReader();
                    dirReader.readEntries((entries) => {
                        const promises = entries.map(entry =>
                            traverseFileTree(entry, path + item.name + '/', files)
                        );
                        Promise.all(promises).then(resolve);
                    });
                } else {
                    resolve();
                }
            });
        }

        // Disconnect terminal before navigating
        function navigateAway(url) {
            connected = false;
            if (pollController) {
                pollController.abort();
            }
            // Fire-and-forget disconnect
            fetch(`/terminal/${sessionId}/disconnect`, {
                method: 'POST',
                keepalive: true
            }).catch(() => {});
            window.location.href = url;
        }

        // Close modals on escape
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                hideUpload();
                hideFiles();
            }
        });

        // Close modals when clicking outside
        document.querySelectorAll('.modal').forEach(modal => {
            modal.addEventListener('click', (e) => {
                if (e.target === modal) {
                    modal.classList.remove('show');
                }
            });
        });

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            connected = false;
            if (pollController) {
                pollController.abort();
            }
            // Fire-and-forget disconnect (keepalive ensures it sends)
            fetch(`/terminal/${sessionId}/disconnect`, {
                method: 'POST',
                keepalive: true
            }).catch(() => {});
        });

        // Initialize terminal when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initTerminal);
        } else {
            initTerminal();
        }

    </script>
</body>
</html>
